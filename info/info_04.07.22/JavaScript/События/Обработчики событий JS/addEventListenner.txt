Метод addEventListener() присоединяет обработчик события к определенному элементу. 
При этом новый обработчик события не переписывает уже существующие обработчики событий.

Синтаксис:

   элемент.addEventListener(событие, функция, useCapture);

Первый параметр — тип события (например, "click" или "mousedown").

Второй параметр — функция, которая будет вызываться при возникновении события.

Третий параметр — логическое значение (true/false), определяющее следует ли отправить
 событие дальше ("всплывание") или нужно закрыть это событие. Этот параметр необязателен.




Ниже пример когда два обработчика вешаются на один элемент и оба работают:

const btn = document.querySelector('button');
btn.addEventListener('click', ()=> {
    alert('Hi');
});

const btn = document.querySelector('button');
btn.addEventListener('click', ()=> {
    alert('Hi_2');
});


Во многих случаях нужно получать данные о том элементе с каторым идет взаимодействие. Для этого существует специальный объект Event.
Этот объект события передается как аргумент в функцию:
можно называть его как угодно, но обычно или event или e

const btn = document.querySelector('button');
btn.addEventListener('click', (e)=> {
    console.log(e);
});

если посмотреть в консоли, то получаю объект с большим колличествой свойств, но самые важные для меня это:
type: "mousemove" - показывает какой тип события произошел
target: butto#btn - элемент на котором произошло событие

И эти свойства открывает огромные возможности!!!!!!!!!

const btn = document.querySelector('button');
btn.addEventListener('click', (e)=> {
    e.target.remove();            ----- вот к примеру при клике на элемент на котором произошло событие, он удаляется.
});



2.Если нужно чтобы событие на обработчике происходили толькол 1 раз:

элемент.addEventListener(событие, функция, useCapture);

то нужно использовать третий агрумент - useCapture

capture:  Boolean указывает, что события этого типа будут отправлены зарегистрированному обработчику listener перед отправкой на EventTarget,
 расположенный ниже в дереве DOM.


once: Boolean указывает, что обработчик должен быть вызван не более одного раза после добавления. Если true, 
обработчик автоматически удаляется при вызове.


passive:  Boolean указывает, что обработчик никогда не вызовет preventDefault(). Если всё же вызов будет произведён, 
браузер должен игнорировать его и генерировать консольное предупреждение. Пример Улучшение производительности прокрутки с помощью passive true


Синтаксис:
третьим аргументом добавляю {once: true}

btn.addEventListener('click', (e)=> {
    e.target.remove(), {once: true};      
});



3. Если нужно повесить один обработчик на несколько элементов ( к примеру на 3 кнопки стразу)

И тут снова вожно понимать что невозможно навесить на полученный объект( или псеводомассив) с элементами ,
поэтому нужно этот массив перебрать и на каждый элемент повесить обработчик:

consts btn = document.querySelectorAll('button');

btns.forEach(item => {            ---- item - каждая кнопка в массиве по порядку
    item.addEventListener('click', (e)=> {
        console.log(e);
    }
});



