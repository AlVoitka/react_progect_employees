Все что будет вносится в инпуты будет относится к состоянию этой формы, соответственно нужно переписать ее на 
классовый подход.

Так было:

import './employees-add-form.css';

const EmployeesAddForm = () => {
    return (
        <div className="app-add-form">
            <h3>Добавьте нового сотрудника</h3>
            <form
                className="add-form d-flex">
                <input type="text"
                    className="form-control new-post-label"
                    placeholder="Как его зовут?" />
                <input type="number"
                    className="form-control new-post-label"
                    placeholder="З/П в $?" />

                <button type="submit"
                        className="btn btn-outline-light">Добавить</button>
            </form>
        </div>
    )
}

export default EmployeesAddForm;

переделка:

1.сначала импортрую компонент:

import { Component } from 'react';

2. Переписываю на класс и все что было возвращено из return помещаю в метод render():

вот что получилось:

import { Component } from 'react';  -- импортировал компонент

import './employees-add-form.css';

class EmployeesAddForm extends Component {   ----- назначил класс
    render() {   ----------------------------все обернул в рендер
        return (
            <div className="app-add-form">
                <h3>Добавьте нового сотрудника</h3>
                <form
                    className="add-form d-flex">
                    <input type="text"
                        className="form-control new-post-label"
                        placeholder="Как его зовут?" />
                    <input type="number"
                        className="form-control new-post-label"
                        placeholder="З/П в $?" />
    
                    <button type="submit"
                            className="btn btn-outline-light">Добавить</button>
                </form>
            </div>
        )
    }
}

export default EmployeesAddForm;

3. Осталось создать конструктор и назначить внутреннее состояние:
создаю конструктор и передаю в него пропсы. Вызываю super с пропсами. И создаю объект this.state 
с двумя состояниями name и salary.

    constructor(props) {
        super(props);
        this.state = {
            name: '',
            salary: ''
        }
    }
4. Для отслеживания вводимого значения в инпут вешаю обработчик по клику 
и прописываю метод который будт подходит сразу к двум инпутам из проекта:

onChange={this.onValueChange}  - вот обработчик

и назначу дополнительные атрибуты для инпутов:
Для одного:
name="name"


Для второго:
name="salary"


они нужны чтобы правильно прописать метод(вытащить значение)

И создаю метод:

    onValueChange = (e) => {  - метод принемает в себя аргумент в виде объекта события
    и внутри меняю состояние
        this.setState({
            [e.target.name] : e.target.value
        })
    }

5. Для того чтобы реакт-компонент  рендерил форму  и контролировал ее поведение в ответ на пользовательский ввод,
то нужно обязательно добавлять атрибут value к форме и в него помещать значение из объекта this.state

value={this.state}

Но для лучшей читаемости кода лучше это диструктурировать:
создать переменные и им присвоить this.state:

const {name, salary} = this.state;

и помещаю их в атрибут:
value={name} 
value={salary}

Что получается в итого:
Теперь компанент при работе с импутом проходит следующие этапы
- импут запускает событие по клику onChange= и он запускает метод onValueChange в котором метод .setState
изменяет состояние и записывает новое сосояние в конструктор в объект .state.

    constructor(props) {
        super(props);
        this.state = {
            name: '',  -- вот сюда 
            salary: ''  --- и сюда
        }

       Далее .state вызывает метод render() который изменит состояние компонента и в атрибут value запишится 
       актуальное значение компонента , что по итогу и называется управляемым компонентом.!!!!!!!!!